<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on Rocko&#39;s blog</title>
    <link>https://rocko.vip/categories/android/</link>
    <description>Recent content in Android on Rocko&#39;s blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 27 Nov 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://rocko.vip/categories/android/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Android Robolectric 加载运行本地 so 动态库</title>
      <link>https://rocko.vip/posts/android-robolectric-%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C%E6%9C%AC%E5%9C%B0-so-%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Sun, 27 Nov 2016 00:00:00 +0000</pubDate>
      <guid>https://rocko.vip/posts/android-robolectric-%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C%E6%9C%AC%E5%9C%B0-so-%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://robolectric.org&#34;&gt;Robolectric&lt;/a&gt; 是 Android 的单元测试框架，运行无需 Android 真机环境直接运行在 JVM 之上，所以在 test case 运行速度效率上有了很大提升，接近于 Java JUnit test（&lt;code&gt;JUnit test &amp;gt; Robolectric &amp;gt;&amp;gt; androidTest&lt;/code&gt;）。不过&lt;strong&gt;框架本身并不支持 &lt;code&gt;so&lt;/code&gt; 本地库的加载使用&lt;/strong&gt;，加载时会直接报错，因为实际上运行环境是电脑机器，而我们打出的 so 文件是给手机上用的所以当然会报错。虽然在 &lt;a href=&#34;https://github.com/robolectric/robolectric&#34;&gt;GitHub&lt;/a&gt; 上很多人问过关于使用 so 的问题但基本都建议说不要在单元测试中去加载本地库，这在原则上是要这么做，但可能有些项目中做起来就有些困难了，比如在代码结构不够好、依赖耦合较大或者本身就对 so 库依赖很大的情况下。所以下面说说在项目中 Robolectric 要怎么解决需要加载运行本地 so 库这个问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MVVM_Android-CleanArchitecture</title>
      <link>https://rocko.vip/posts/mvvm_android-cleanarchitecture/</link>
      <pubDate>Sat, 07 Nov 2015 00:00:00 +0000</pubDate>
      <guid>https://rocko.vip/posts/mvvm_android-cleanarchitecture/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&amp;ldquo;Architecture is About Intent, not Frameworks&amp;rdquo;    - &lt;a href=&#34;http://cleancoder.com/&#34;&gt;Robert C. Martin (Uncle Bob)&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Uncle Bob 的这句话套在 MVVM 上也是适用的, MVVM 也仅仅是架构&lt;code&gt;模式&lt;/code&gt;（Architectural pattern），其有一套自己的理论概念（pattern）而不是规定的具体实现（或 Frameworks）。早之前在知乎上相关问题的回答（&lt;a href=&#34;http://www.zhihu.com/question/30976423/answer/50181505&#34;&gt;android UI设计MVVM设计模式讨论？&lt;/a&gt;）中也简单提到过 MVVM 了，M-V-X 的关系如上图，那么这一次博主把 &lt;a href=&#34;https://github.com/android10&#34;&gt;Fernando Cejas(android10)&lt;/a&gt; 的 &lt;a href=&#34;https://github.com/android10/Android-CleanArchitecture&#34;&gt;Android-CleanArchitecture&lt;/a&gt; 项目中的 MVP 实现重构成了用 MVVM 来实现。所以看这篇文章最好是先搞清了 &lt;a href=&#34;https://github.com/android10&#34;&gt;Fernando Cejas(android10)&lt;/a&gt; 的 &lt;a href=&#34;https://github.com/android10/Android-CleanArchitecture&#34;&gt;Android-CleanArchitecture&lt;/a&gt; sample app 和对应的两篇文章（见参考）。整个历程也算比较愉快，没什么不良反应，这篇文章理所当然会重点说说 MVVM 的实现、 Data Binding 等相关的东西。那为什么拥抱 MVVM 呢。当然是 Google 推出官方的 &lt;a href=&#34;https://developer.android.com/tools/data-binding/guide.html&#34;&gt;data binding&lt;/a&gt; 啦，下一次的 Android MVVM 热潮应该就是 data binding 放出正式版了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【译】解决共享元素在系统UI上绘制的问题</title>
      <link>https://rocko.vip/posts/%E8%AF%91%E8%A7%A3%E5%86%B3%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%E5%9C%A8%E7%B3%BB%E7%BB%9Fui%E4%B8%8A%E7%BB%98%E5%88%B6%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 19 Jun 2015 00:00:00 +0000</pubDate>
      <guid>https://rocko.vip/posts/%E8%AF%91%E8%A7%A3%E5%86%B3%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%E5%9C%A8%E7%B3%BB%E7%BB%9Fui%E4%B8%8A%E7%BB%98%E5%88%B6%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;原文链接 ：&lt;a href=&#34;https://plus.google.com/+AlexLockwood/posts/RPtwZ5nNebb&#34;&gt;Dealing with shared elements that draw on top of the system UI&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;目前为止，我在使用 Activity transitions 中遇到的一个比较烦人的小问题：共享元素会部分地覆盖掉 Status/Navigation/Action Bar，一旦开始过渡动画，共享元素就会很唐突地从系统 UI 下 &lt;code&gt;弹出&lt;/code&gt;。这一不和谐的表现可以看看下面这个视频：&lt;/p&gt;</description>
    </item>
    <item>
      <title>【译】NotRxJava懒人专用指南</title>
      <link>https://rocko.vip/posts/%E8%AF%91notrxjava%E6%87%92%E4%BA%BA%E4%B8%93%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Tue, 05 May 2015 00:00:00 +0000</pubDate>
      <guid>https://rocko.vip/posts/%E8%AF%91notrxjava%E6%87%92%E4%BA%BA%E4%B8%93%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;原文链接 : &lt;a href=&#34;http://yarikx.github.io/NotRxJava/&#34;&gt;NotRxJava guide for lazy folks&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;原文作者 : &lt;a href=&#34;http://yarikx.github.io/&#34;&gt;Yaroslav Heriatovych&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;译文出自 : &lt;a href=&#34;http://www.devtf.cn/&#34;&gt;开发技术前线 www.devtf.cn&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;译者 : &lt;a href=&#34;https://github.com/zhengxiaopeng&#34;&gt;Rocko&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;校对者: &lt;a href=&#34;https://github.com/bboyfeiyu&#34;&gt;Mr.Simple&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;状态 : 完成校对&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果你是一位 Android 开发者，那么这些天你可能已经听到或看到一些关于 RxJava 满天飞的宣传了。RxJava 是一个能让你摆脱编写一些复杂繁琐的代码去处理异步事件的库。一旦开始在你的项目中使用，你会对它爱不释手的。&lt;/p&gt;&#xA;&lt;p&gt;然而，RxJava 有个缺陷，它需要一个陡峭的学习过程。对于一个从未接触使用过 RxJava 的人来说，是很难一次就领会到它的精髓所在的，对于它的一些使用方法你也可能会很迷惑。在项目中使用它意味着你需要稍微地改变一下你的代码编写思路，另外，这样的学习曲线会使得在项目中因为大规模的使用RxJava而引发一些问题。&lt;/p&gt;&#xA;&lt;p&gt;当然，关于如何去使用 RxJava 已经有许多的教程和代码范例了。感兴趣的开发者可以访问 RxJava 的官方 Wiki，里面有关于什么是 Observable 以及它和 Iterable、Future 之间关系的很好的解释。Wiki 里有一篇很有用的文章：How To Use RxJava，这篇文章包含怎么去发送事件流并且打印出它们的介绍以及它的样例代码。&lt;/p&gt;&#xA;&lt;p&gt;但我们要明确的是在还没有学习什么是 Observable 的前提下了解 RxJava 用来解决什么问题以及它是怎么帮助我们组织起异步代码的。&lt;/p&gt;&#xA;&lt;p&gt;我这篇文章的定位就是 RxJava 官方文档的“前篇”，读完这篇文章能更好地去理解 RxJava 所解决的问题。文章中也有一个小 Demo，就是自己怎么去整理那些凌乱的代码，然后看看我们在没有使用 RxJava 的情况下是怎么去遵循 RxJava 基本原则的。&lt;/p&gt;&#xA;&lt;p&gt;所以，如果你仍有足够的好奇的话就让我们开始吧！&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android View.OnTouchListener 的子类</title>
      <link>https://rocko.vip/posts/android-view-ontouchlistener-%E7%9A%84%E5%AD%90%E7%B1%BB/</link>
      <pubDate>Sun, 26 Apr 2015 00:00:00 +0000</pubDate>
      <guid>https://rocko.vip/posts/android-view-ontouchlistener-%E7%9A%84%E5%AD%90%E7%B1%BB/</guid>
      <description>&lt;p&gt;如下是几个实现了 &lt;a href=&#34;http://developer.android.com/reference/android/view/View.OnTouchListener.html&#34;&gt;OnTouchListener&lt;/a&gt; 接口的子类，OnTouchListener 我们是再熟悉不过了，在 Hello World 开始就接触了，但在 Support V4 中还有它的 3 个子类我们平时可能使用的较少但就其功能而言还是对我们很有帮助的。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;** &lt;a href=&#34;http://developer.android.com/reference/android/support/v4/widget/AutoScrollHelper.html&#34;&gt;AutoScrollHelper&lt;/a&gt; ** 抽象类，用于控件边缘触发自动滚动。&lt;/li&gt;&#xA;&lt;li&gt;** &lt;a href=&#34;http://developer.android.com/reference/android/support/v4/widget/ListViewAutoScrollHelper.html&#34;&gt;ListViewAutoScrollHelper&lt;/a&gt; ** 用于 ListView，目前 SDK 里的唯一 AutoScrollHelper 实现类。&lt;/li&gt;&#xA;&lt;li&gt;** &lt;a href=&#34;http://developer.android.com/reference/android/widget/ZoomButtonsController.html&#34;&gt;ZoomButtonsController&lt;/a&gt; ** 用于控制缩放控件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;三者的功能体现在 AutoScrollHelper 和 ZoomButtonsController，前者用于实现控件的自动滚动而后者用于对缩放控件（缩小放大按钮）的处理。&lt;/p&gt;&#xA;&lt;h2 id=&#34;autoscrollhelper&#34;&gt;AutoScrollHelper&lt;/h2&gt;&#xA;&lt;p&gt;为了更好阐述它的功能，我们先来看如下的 Gif 图：&#xA;&lt;img src=&#34;https://rocko.vip/images/27sjkadg21bkagd021qhakdhaw8_da2q.gif.png&#34; alt=&#34;ListViewAutoScrollHelper&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;所以，他能完成的功能就是在 View 的边缘长按时能自动地滚动视图。下面是它的主要方法说明：&lt;/p&gt;</description>
    </item>
    <item>
      <title>【译】Spans，一个强大的概念</title>
      <link>https://rocko.vip/posts/%E8%AF%91spans%E4%B8%80%E4%B8%AA%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Wed, 04 Mar 2015 00:00:00 +0000</pubDate>
      <guid>https://rocko.vip/posts/%E8%AF%91spans%E4%B8%80%E4%B8%AA%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
      <description>&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;&#xA;&lt;p&gt;原文：&lt;a href=&#34;http://flavienlaurent.com/blog/2014/01/31/spans/&#34;&gt;Spans, a Powerful Concept.&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;最近，我写了一篇关于 NewStand app 和 app 上 ActionBar 的图标的翻转动效的文章。&lt;a href=&#34;http://cyrilmottier.com/&#34;&gt;Cyril Mottier&lt;/a&gt; 建议我采用一个很优雅的方案，即使用 Spans 去淡入淡出 ActionBar 的标题。&#xA;此外，我一直想尝试所有可用的 Sapn 色的类型：&lt;a href=&#34;http://developer.android.com/reference/android/text/style/ImageSpan.html&#34;&gt;ImageSpan&lt;/a&gt;、&lt;a href=&#34;http://developer.android.com/reference/android/text/style/BackgroundColorSpan.html&#34;&gt;BackgroundColorSpan&lt;/a&gt; 等。他们非常简单易用但是（也）没有任何关于它们的文档和详细信息。&#xA;因此，在这篇文章中，我将探索在 Spans 的框架下什么是可以做的，然后，我将会告诉你怎么去进阶使用 Spans。&#xA;你可以下载和安装 &lt;a href=&#34;https://github.com/flavienlaurent/spans/raw/master/sample.apk&#34;&gt;demo 程序&lt;/a&gt;，查看&lt;a href=&#34;https://github.com/flavienlaurent/spans&#34;&gt;源码&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>仿有道云笔记头像背景</title>
      <link>https://rocko.vip/posts/%E4%BB%BF%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%E5%A4%B4%E5%83%8F%E8%83%8C%E6%99%AF/</link>
      <pubDate>Mon, 02 Mar 2015 00:00:00 +0000</pubDate>
      <guid>https://rocko.vip/posts/%E4%BB%BF%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%E5%A4%B4%E5%83%8F%E8%83%8C%E6%99%AF/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;如题，本文模仿实现有道云笔记的侧滑菜单中的头像背景的效果，这一效果可用借鉴使用，毕竟大多数时候我们在应用上的资料可能没有像play、微博等的个人页面的自定义背景图。没用过这款应用的童鞋可以下载这款应用看看。&lt;/p&gt;&#xA;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;&#xA;&lt;p&gt;先来看看有道云笔记上的图片（重点是头像上的背景图，真机看起来效果比较好）：&#xA;&lt;img src=&#34;https://rocko.vip/images/%E4%BB%BF%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%E5%A4%B4%E5%83%8F%E8%83%8C%E6%99%AF-1.jpg.png&#34; alt=&#34;有道云笔记效果图&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在手机上没找到背景的效果图，应该是在手机上生成的效果图，根据它的背景图片可以看出图片时黑白的而且是有点朦胧感，所以经过分析和实验得到做这一效果可以使用的方法：黑白效果用&lt;code&gt;ColorFilter&lt;/code&gt;实现、模糊效果可以用&lt;code&gt;RenderScript&lt;/code&gt;的API实现。代码的步骤也是先得到黑白的Bitmap再把它模糊处理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android中的MVP</title>
      <link>https://rocko.vip/posts/android%E4%B8%AD%E7%9A%84mvp/</link>
      <pubDate>Fri, 06 Feb 2015 00:00:00 +0000</pubDate>
      <guid>https://rocko.vip/posts/android%E4%B8%AD%E7%9A%84mvp/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;MVP 作为一种 MVC 的演化版本在 Android 开发中受到了越来越多的关注，但在项目开发中选择一种这样的软件设计模式需保持慎重心态，一旦确定使用 MVP 作为你 App 的开发模式那么你就最好坚持做下去，如果在使用 MVP 模式开发过程中发现问题而且坑越来越大，那么就呵呵了。要知道在 Android 上 MVP 在现在为止并没有统一的标准或者框架，不像 Java Web 领域的项目有 SSH 这三个成熟稳重强而有力的三剑客支持推动着，所以在运用 MVP 时一定要做好自己的理解，并且尽量预知自己 App 各模块的需求以便提前做好充分的设计工作。当然 MVP 既然能出现那么必然有它的优点的，不然谁会理会这个冒出来的东西，下面就对 Android 中 MVP 做一些阐述。&lt;/p&gt;&#xA;&lt;h2 id=&#34;mvp简介&#34;&gt;MVP简介&lt;/h2&gt;&#xA;&lt;p&gt;相信大家对 MVC 都是比较熟悉了：&lt;code&gt;M-Model-模型&lt;/code&gt;、&lt;code&gt;V-View-视图&lt;/code&gt;、&lt;code&gt;C-Controller-控制器&lt;/code&gt;，MVP作为MVC的演化版本，也是作为用户界面（用户层）的实现模式，那么类似的MVP所对应的意义：&lt;code&gt;M-Model-模型&lt;/code&gt;、&lt;code&gt;V-View-视图&lt;/code&gt;、&lt;code&gt;P-Presenter-表示器&lt;/code&gt;。从MVC和MVP两者结合来看，Controlller/Presenter在MVC/MVP中都起着逻辑控制处理的角色，起着控制各业务流程的作用。而MVP与MVC最不同的一点是M与V是不直接关联的也是就Model与View不存在直接关系，这两者之间间隔着的是Presenter层，其负责调控View与Model之间的间接交互，MVP的结构图如下所示，对于这个图理解即可而不必限于其中的条条框框，毕竟在不同的场景下多少会有些出入的。在Android中很重要的一点就是对UI的操作基本上需要异步进行也就是在MainThread中才能操作UI，所以对View与Model的切断分离是合理的。此外Presenter与View、Model的交互使用接口定义交互操作可以进一步达到松耦合也可以通过接口更加方便地进行单元测试。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rocko.vip/images/Android%E4%B8%AD%E7%9A%84MVP_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android 错误集锦ing...</title>
      <link>https://rocko.vip/posts/android-%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6ing/</link>
      <pubDate>Thu, 05 Feb 2015 00:00:00 +0000</pubDate>
      <guid>https://rocko.vip/posts/android-%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6ing/</guid>
      <description>&lt;p&gt;Fork from my csdn blog: &lt;a href=&#34;http://blog.csdn.net/bbld_/article/details/39520249&#34;&gt;Android 错误集锦(ing&amp;hellip;)&lt;/a&gt;.&#xA;Last update time: &lt;em&gt;2016-03-06 23:34:26&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;p&gt;温馨提示：&lt;code&gt;Ctrl+F查找&lt;/code&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;系统环境：&lt;/strong&gt;&#xA;Windows7 64位&#xA;&lt;strong&gt;问题描述：&lt;/strong&gt;&#xA;Eclipse真机无法打印log信息&#xA;&lt;strong&gt;错误提示：&lt;/strong&gt;&#xA;&amp;hellip;&#xA;&lt;strong&gt;解决方案：&lt;/strong&gt;&#xA;window&amp;ndash;&amp;gt;show view&amp;ndash;&amp;gt;android-&amp;gt;devices，打开devices，点击右边的截屏图片的按钮。等到出现截图的时候，logcat就出来信息了（不保证每次都有用）&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;系统环境：&lt;/strong&gt;&#xA;Windows7 64位&#xA;&lt;strong&gt;问题描述：&lt;/strong&gt;&#xA;xml（资源）文件里面的错误&#xA;&lt;strong&gt;错误提示：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;android: invalid start tag xxxxx 错误原因&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&#xA;今天在学shape这个属性,结果创建的xml总是提示这个错误百思不得其解,后来找到原因了我把这个xml文件放错了位置,放到了res/layout路径下应该放在drawable的路径下才对&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;系统环境：&lt;/strong&gt;&#xA;Windows7 64位&#xA;&lt;strong&gt;问题描述：&lt;/strong&gt;&#xA;无法run(运行)工程&#xA;&lt;strong&gt;错误提示：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Conversion to Dalvik format failed with error &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&#xA;第一种情况包导入错误.点击工程&amp;ndash;&amp;gt;build path&amp;ndash;&amp;gt;libraries&amp;ndash;&amp;gt;选中android1.x 或者android2.x ，点击remove。然后再点击add library&amp;ndash;&amp;gt;User Library &amp;ndash;&amp;gt;next&amp;ndash;&amp;gt;User Libraries&amp;ndash;&amp;gt;new 你取一个名字 比如android2.1 点击OK，选中android2.1&amp;ndash;&amp;gt;add jars&amp;ndash;&amp;gt;\android-sdk-windows\platforms\android-7\android.jar 点击打开，点击ok&amp;ndash;&amp;gt;finish.&lt;/p&gt;&#xA;&lt;p&gt;第二种情况签名时没有成功。签名：java -jar signapk.jar platform.x509.pem platform.pk8 e:huaworkspace\hua\bin\hua.apk e:huaworkspace\hua\bin\hua_signaed.apk，如果hua_signaed.apk签名失败，那么请到你的工作目录中将hua_signaed.apk delete掉。&lt;/p&gt;&#xA;&lt;p&gt;第三种情况包冲突，请到工程目录下将相同的包删除，重新导入一个，这一点和第一种情况类似，不过这是针对其他包，不是android包&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;系统环境：&lt;/strong&gt;&#xA;Windows7 64位&#xA;&lt;strong&gt;问题描述：&lt;/strong&gt;&#xA;导入SlidingMenu和SlidingMenu所依赖的actionbarsherlock包后再导入supportv7（用来支持ActionBar），工程一直报错、无法生成R文件。&#xA;&lt;strong&gt;错误提示：&lt;/strong&gt;&#xA;&amp;hellip;&#xA;&lt;strong&gt;解决方案：&lt;/strong&gt;&#xA;不用导入v7包了，因为actionbarsherlock已经支持ActionBar，再导入v7会有冲突。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;系统环境：&lt;/strong&gt;&#xA;Windows7 64位&#xA;&lt;strong&gt;问题描述：&lt;/strong&gt;&#xA;FragmentTransaction使用问题。&#xA;&lt;strong&gt;错误提示：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;java.lang.IllegalStateException: commit already called.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&#xA;是因为你的ft事务是全局的变量，只能commit一次。所以用两个局部ft事务去做commit即可。 原文地址：http://blog.csdn.net/knxw0001/article/details/9363411 &lt;br&gt;&#xA;补充：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Java&#34; data-lang=&#34;Java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;FragmentManager fragmentManager &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getSupportFragmentManager(); &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;FragmentTransaction fragmentTransaction &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fragmentManager.&lt;span style=&#34;color:#a6e22e&#34;&gt;beginTransaction&lt;/span&gt;(); &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;detailFragment &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ProductDetailFragment(productId); &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;commentFragment &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ProductCommentFragment(productId); &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fragmentTransaction.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(R.&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;viewgroup&lt;/span&gt;, detailFragment); &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fragmentTransaction.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(R.&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;viewgroup&lt;/span&gt;, commentFragment); &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fragmentTransaction.&lt;span style=&#34;color:#a6e22e&#34;&gt;commit&lt;/span&gt;(); &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//下面这个是调用的时候需要用新的局部变量  &lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;getSupportFragmentManager().&lt;span style=&#34;color:#a6e22e&#34;&gt;beginTransaction&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;hide&lt;/span&gt;(commentFragment).&lt;span style=&#34;color:#a6e22e&#34;&gt;show&lt;/span&gt;(detailFragment).&lt;span style=&#34;color:#a6e22e&#34;&gt;commit&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;系统环境：&lt;/strong&gt;&#xA;Windows7 64位&#xA;&lt;strong&gt;问题描述：&lt;/strong&gt;&#xA;使用Genymotion调试出现错误INSTALL_FAILED_CPU_ABI_INCOMPATIBLE&#xA;&lt;strong&gt;错误提示：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Installation error: INSTALL_FAILED_CPU_ABI_INCOMPATIBLE&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Please check logcat output &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; more details.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Launch canceled!&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&#xA;点击下载&lt;a href=&#34;http://pan.baidu.com/s/1c0ELjzi#dir/path=%2FJustDoIt%2F%E4%B8%80%E4%BA%9B%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5%2F%E6%9C%89%E9%81%93&#34;&gt;Genymotion-ARM-Translation.zip&lt;/a&gt;&#xA;将你的虚拟器运行起来，将下载好的zip包用鼠标拖到虚拟机窗口中，出现确认对跨框点OK就行。然后重启你的虚拟机。&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用Gradle发布项目到JCenter仓库</title>
      <link>https://rocko.vip/posts/%E4%BD%BF%E7%94%A8gradle%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0jcenter%E4%BB%93%E5%BA%93/</link>
      <pubDate>Mon, 02 Feb 2015 00:00:00 +0000</pubDate>
      <guid>https://rocko.vip/posts/%E4%BD%BF%E7%94%A8gradle%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0jcenter%E4%BB%93%E5%BA%93/</guid>
      <description>&lt;p&gt;这篇文章介绍通过Gradle把开源项目发布到公共仓库JCenter中，方便你我他的事情，我们都是很懒的嘛。JCenter现在是Android Studio中repositories的默认节点了，之前是Maven的，不过JCenter是兼容Maven的，所以放心使用。步骤基本是按&lt;a href=&#34;https://www.virag.si/2015/01/publishing-gradle-android-library-to-jcenter/&#34;&gt;Publishing Gradle Android Library to jCenter Repository&lt;/a&gt;这里来的，英文能看的直接看这篇也行。下面我的步骤正式开始，发布到JCenter仓库的是我的项目：&lt;a href=&#34;https://github.com/zhengxiaopeng/BounceProgressBar&#34;&gt;BounceProgressBar&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;申请bintray账号&#34;&gt;申请Bintray账号&lt;/h2&gt;&#xA;&lt;p&gt;Bintray的基本功能类似于Maven Central，一样的我们需要一个账号，&lt;a href=&#34;https://bintray.com/&#34;&gt;Bintray传送门&lt;/a&gt;，注册完成后第一步算完成了。&#xA;&lt;code&gt;Note: &lt;/code&gt; 如果你的账号（主页）中没有添加 &lt;strong&gt;maven&lt;/strong&gt; 记得添加上。点击 &lt;code&gt;Add New Repositories&lt;/code&gt; 然后 name 和 type 写上 &lt;code&gt;maven&lt;/code&gt; 即可。&lt;/p&gt;&#xA;&lt;h2 id=&#34;生成项目的javadoc和source-jars&#34;&gt;生成项目的JavaDoc和source JARs&lt;/h2&gt;&#xA;&lt;p&gt;简单的说生成的这两样东西就是我们在下一步中上传到远程仓库JCenter上的文件了。这一步需要&lt;code&gt;android-maven-plugin&lt;/code&gt;插件，所以我们需要在项目的build.gradle（Top-level build file，项目最外层的build.gradle文件）中添加这个构建依赖，如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-gradle&#34; data-lang=&#34;gradle&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;buildscript &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    repositories &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        jcenter&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dependencies &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        classpath &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;com.android.tools.build:gradle:1.0.0&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        classpath &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;com.github.dcendents:android-maven-plugin:1.2&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// NOTE: Do not place your application dependencies here; they belong&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// in the individual module build.gradle files&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;allprojects &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    repositories &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        jcenter&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在你需要发布的那个module（我这里的即是library）的build.gradle里配置如下内容：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android Studio jar、so、library项目依赖</title>
      <link>https://rocko.vip/posts/android-studio-jarsolibrary%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Sat, 13 Dec 2014 00:00:00 +0000</pubDate>
      <guid>https://rocko.vip/posts/android-studio-jarsolibrary%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;&#xA;&lt;p&gt;Android Studio(以下简称AS)在13年I/O大会后放出预览版到现在放出的正式版1.0（PS.今天又更新到1.0.1了）历时一年多了，虽然Google官方推出的Android开发者的IDE对我们Android DEV是很有吸引力的，但考虑到beta版还是太多问题所以自己主要还是把AS当做尝鲜为主，每放出一个较大更新就下载下来试试，感觉还是挺好的，渐渐用AS的人越来越多，Github上的项目也基本是AS的了，Google的sample也采用AS，所以使用Eclipse跟外界交流越来越困难啊。到现在&lt;code&gt;android-studio-bundle-135.1629389&lt;/code&gt;AS正式版的推出，我们有理由从Eclipse迁移到AS了。&lt;br&gt;&#xA;要迁移到AS中开发那么要掌握AS中的项目管理是必须的，基本的new project、run什么的就不提了，这篇文章记录我在AS中在项目中解决jar包、library项目依赖、so动态链接库的问题，版本控制Git、SVN等这篇文章不涉及。这么多废话后下面开始。&lt;/p&gt;&#xA;&lt;h1 id=&#34;eclipse跟as的不同&#34;&gt;Eclipse跟AS的不同&lt;/h1&gt;&#xA;&lt;p&gt;从Eclipse到AS不要带着在Eclipse中的主观色彩去在AS中使用，从项目的构成到构建是不同的，下面列举在Eclipse和AS中的一些概念的区别：&lt;/p&gt;&#xA;&lt;h2 id=&#34;workspace和project&#34;&gt;WorkSpace和Project&lt;/h2&gt;&#xA;&lt;p&gt;Eclipse的WorkSpace和AS的Project说的可以说是一个东西，也就是说你可以把在AS中的Project理解为WorkSpace。&#xA;&lt;img src=&#34;https://rocko.vip/images/Android-Studio-jar%E3%80%81so%E3%80%81library%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96_1.jpg?imageView2/2/w/400/h/400/q/100&#34; alt=&#34;&#34;&gt; 所以你在AS中new一个Project相当于在Eclipse中重开了一个WorkSpace，注意第一个箭头，显示模式为Project，建议刚用AS时用这种，方便了解里面的文件结构。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android Volley自定义Request(JacksonRequest、GsonRequest)</title>
      <link>https://rocko.vip/posts/android-volley%E8%87%AA%E5%AE%9A%E4%B9%89request-jacksonrequestgsonrequest/</link>
      <pubDate>Fri, 05 Dec 2014 00:00:00 +0000</pubDate>
      <guid>https://rocko.vip/posts/android-volley%E8%87%AA%E5%AE%9A%E4%B9%89request-jacksonrequestgsonrequest/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;&#xA;&lt;p&gt;Volley是一个强大的HTTP库，让Android的的网络操作变得容易、高效、快速。在少数据的高并发情况下它的优势很明显，但在大文件的上传或者下载操作中就并不适用了，这种情况下是建议使用传统方式或者其它框架来实现的。&#xA;&lt;em&gt;它的优点再罗列如下：&lt;/em&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自动管理网络请求&lt;/li&gt;&#xA;&lt;li&gt;多并发的网络连接&lt;/li&gt;&#xA;&lt;li&gt;通过标准的HTTP cache coherence(高速缓存一致性)使得磁盘与内存缓存不可见(Transparent)&lt;/li&gt;&#xA;&lt;li&gt;支持指定请求的优先级&lt;/li&gt;&#xA;&lt;li&gt;支持取消已经发出的请求。你可以取消单个请求，也可以设置请求取消的块或范围&lt;/li&gt;&#xA;&lt;li&gt;框架是容易被定制的，例如，重试或者回退功能&lt;/li&gt;&#xA;&lt;li&gt;强大的指令使得你可以容易地去异步网络操作和(网络获取数据后)的UI设置&lt;/li&gt;&#xA;&lt;li&gt;(内置)Debugging和tracing工具&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;自定义request实现&#34;&gt;自定义Request实现&lt;/h1&gt;&#xA;&lt;p&gt;上面提到的优点：Volley是容易被定制的，它的易扩展性在这里的自定义Request实现中就很好的体现了出来。自定义Request是通过继承Volley中最核心的Request类来实现的。在我们的Request来解析json数据时，注意处理复杂json数据的解析可扩展性。比如，我们一般都需要把JSON数据解析成我们的实体对象，如下面使用示例中的Weather对象，如果我们的实体比较复杂时就需要自定义自己的Type去给Jackson、Gson去处理了，不然一般都会默认的给解析成HashMap式的键值对造成FC或者get不到属性。对于Jackson，使用Jackson库里的&lt;code&gt;TypeReference&lt;/code&gt;类来实现；对于Gson，使用Gson库中的&lt;code&gt;TypeToken&lt;/code&gt;类来实现。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
